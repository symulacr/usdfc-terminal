# Server Function Architecture Fix Plan

## Problem Analysis

### Current Structure
```
crates/
├── core/          (types, config, error - no proc-macros)
├── backend/       (server functions + SSR implementations)
│   ├── server_fn.rs   (16 server functions with #[server] macro)
│   ├── rpc.rs, blockscout.rs, subgraph.rs, gecko.rs
│   ├── cache.rs, historical.rs
│   └── Dependencies: tokio, axum, reqwest, rusqlite (NOT WASM-compatible)
└── terminal/      (Leptos UI)
    └── pages/     (imports from usdfc_backend::server_fn)
```

### The Issue
- Server functions are in `backend` crate
- Backend has SSR-only deps (tokio, axum, rusqlite) that can't compile to WASM
- When building for hydrate (WASM), backend crate fails because:
  - tokio needs mio which doesn't support WASM
  - axum, tower, rusqlite are server-only
- Pages import `use usdfc_backend::server_fn::*` which requires backend to compile for WASM

### Why This Happens
The `#[server]` macro generates:
1. Public function signature (available on both client & server)
2. SSR implementation inside `#[cfg(feature = "ssr")]`
3. Client-side RPC stub (auto-generated by Leptos)

For this to work, the **function declarations** must be available in both SSR and hydrate builds,
but the backend crate can't compile for WASM due to its dependencies.

## Solution: Split Server Functions from Backend Logic

### Architecture Change
```
crates/
├── core/          (types, config, error)
├── api/           (NEW: server function declarations only)
│   ├── Cargo.toml (minimal deps: leptos, serde, usdfc-core)
│   └── lib.rs     (all 16 server functions with #[server] macros)
├── backend/       (SSR implementations + services)
│   ├── implementations.rs (impl blocks for server functions)
│   ├── rpc.rs, blockscout.rs, etc. (unchanged)
│   └── Dependencies: tokio, axum, reqwest, rusqlite
└── terminal/      (Leptos UI)
    └── pages/     (imports from usdfc_api)
```

### Key Principles
1. **Server function declarations** = WASM-compatible crate (api)
2. **Server function implementations** = SSR-only crate (backend)
3. **Data types** shared between them = core crate
4. **UI components** = terminal crate

## Implementation Steps

### Phase 1: Create API Crate (30 min)

**1.1 Create new crate structure:**
```bash
mkdir -p crates/api/src
```

**1.2 Create `crates/api/Cargo.toml`:**
```toml
[package]
name = "usdfc-api"
version.workspace = true
edition.workspace = true

[lib]
crate-type = ["rlib"]

[dependencies]
usdfc-core = { path = "../core" }

# Leptos for server function macros
leptos = { workspace = true }

# Serialization (needed for server function params/returns)
serde = { workspace = true, features = ["derive"] }
rust_decimal = { workspace = true, features = ["serde"] }
chrono = { workspace = true, features = ["serde"] }

# No tokio, no axum, no reqwest - WASM compatible!
```

**1.3 Move custom types from backend to core:**

Types to move from `crates/backend/src/server_fn.rs` to `crates/core/src/types.rs`:
- `LendingMarketData`
- `DailyVolumeData`
- `AddressInfo`
- `NormalizedAddress`
- `TokenHolderInfo`
- `USDFCPriceData`
- `ApiHealthStatus`
- `OrderBookData`
- `OrderData`
- `LendingTradeData`
- `WalletBucket`
- `WalletAnalyticsResponse`

These are just data containers with `#[derive(Serialize, Deserialize)]`, no logic.

### Phase 2: Extract Server Function Declarations (45 min)

**2.1 Create `crates/api/src/lib.rs`:**
```rust
//! USDFC API - Server Function Declarations
//!
//! This crate contains ONLY server function signatures with #[server] macros.
//! Implementations are in usdfc-backend crate (SSR only).
//! This crate is WASM-compatible and can be used in both SSR and hydrate builds.

use leptos::*;
use leptos::server_fn::error::NoCustomError;
use usdfc_core::types::*;

type SfnError = ServerFnError<NoCustomError>;

// Re-export types for convenience
pub use usdfc_core::types::{
    ProtocolMetrics, Transaction, Trove, ChartResolution, ChartLookback,
    ChartDataResponse, TVCandle, LendingMarketData, DailyVolumeData,
    AddressInfo, NormalizedAddress, TokenHolderInfo, USDFCPriceData,
    ApiHealthStatus, OrderBookData, LendingTradeData, WalletAnalyticsResponse,
};

/// Get current protocol metrics
#[server(GetProtocolMetrics, "/api")]
pub async fn get_protocol_metrics() -> Result<ProtocolMetrics, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        usdfc_backend::implementations::get_protocol_metrics_impl().await
    }

    #[cfg(not(feature = "ssr"))]
    {
        // This will never execute - Leptos generates RPC stub automatically
        Err(ServerFnError::ServerError("Client-side stub".to_string()))
    }
}

// ... repeat for all 16 server functions
```

**2.2 Each server function pattern:**
```rust
#[server(FunctionName, "/api")]
pub async fn function_name(params) -> Result<ReturnType, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        usdfc_backend::implementations::function_name_impl(params).await
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError("SSR required".to_string()))
    }
}
```

### Phase 3: Move Implementations to Backend (30 min)

**3.1 Create `crates/backend/src/implementations.rs`:**
```rust
//! Server Function Implementations
//!
//! These are the actual SSR implementations called by server functions in usdfc-api.
//! This file contains server-side logic using tokio, RPC clients, caching, etc.

use usdfc_core::types::*;
use leptos::ServerFnError;
use crate::rpc::RpcClient;
use crate::blockscout::BlockscoutClient;
use crate::cache::caches;

type SfnError = ServerFnError<leptos::server_fn::error::NoCustomError>;

/// Implementation for get_protocol_metrics server function
pub async fn get_protocol_metrics_impl() -> Result<ProtocolMetrics, ServerFnError> {
    // Check cache first
    if let Some(cached) = caches::PROTOCOL_METRICS.get("default") {
        return Ok(cached);
    }

    let rpc = RpcClient::new();

    // Make parallel RPC calls
    let (total_supply, total_collateral, active_troves, tcr, stability_pool_balance) = tokio::join!(
        rpc.get_total_supply(),
        rpc.get_total_collateral(),
        rpc.get_trove_owners_count(),
        rpc.get_tcr(),
        rpc.get_stability_pool_balance()
    );

    // ... rest of implementation
}

// ... all other implementations
```

**3.2 Update `crates/backend/src/lib.rs`:**
```rust
pub mod implementations;  // Add this
pub mod rpc;
pub mod blockscout;
// ... etc
```

**3.3 Delete `crates/backend/src/server_fn.rs`** (moved to api + implementations)

### Phase 4: Update Terminal Crate (15 min)

**4.1 Update `crates/terminal/Cargo.toml`:**
```toml
[dependencies]
usdfc-core = { path = "../core" }
usdfc-api = { path = "../api" }  # NEW: always available
usdfc-backend = { path = "../backend", optional = true }  # Only for SSR

[features]
ssr = [
    "dep:usdfc-backend",  # Backend only needed for SSR (main.rs)
    "usdfc-api/ssr",      # Enable SSR feature on api crate
    # ... other ssr deps
]

hydrate = [
    "usdfc-api/hydrate",  # API available in hydrate (no backend!)
    # ... other hydrate deps
]
```

**4.2 Update page imports:**

Change all pages from:
```rust
use usdfc_backend::server_fn::{get_protocol_metrics, get_recent_transactions};
```

To:
```rust
use usdfc_api::{get_protocol_metrics, get_recent_transactions};
```

This can be done with sed:
```bash
find crates/terminal/src/pages -name "*.rs" -exec sed -i 's/use usdfc_backend::server_fn/use usdfc_api/g' {} +
```

### Phase 5: Update Workspace (5 min)

**5.1 Update `Cargo.toml` (workspace root):**
```toml
[workspace]
members = [
    "crates/core",
    "crates/api",      # NEW
    "crates/backend",
    "crates/terminal",
]
```

**5.2 Update `crates/backend/Cargo.toml`:**
```toml
[dependencies]
usdfc-core = { path = "../core" }
usdfc-api = { path = "../api", features = ["ssr"] }  # NEW: for accessing types
# ... rest unchanged
```

### Phase 6: Update Main Entry Point (5 min)

**6.1 Update `crates/terminal/src/main.rs`:**

Change:
```rust
use usdfc_backend::server_fn::*;
```

To:
```rust
use usdfc_api::*;  // Server function declarations
```

The explicit registration section stays the same since it uses the names from api crate.

### Phase 7: Testing (15 min)

**7.1 Test individual crates:**
```bash
cargo check -p usdfc-core
cargo check -p usdfc-api
cargo check -p usdfc-api --features ssr
cargo check -p usdfc-backend
cargo check -p usdfc-analytics-terminal --features ssr
cargo check -p usdfc-analytics-terminal --features hydrate  # This should work now!
```

**7.2 Test full build:**
```bash
CC=gcc cargo leptos build --release -p usdfc-analytics-terminal
```

This should succeed because:
- SSR build: terminal → api (ssr) → backend ✓
- Hydrate build: terminal → api (hydrate) ✗→ backend ✓ (no backend dependency!)

### Phase 8: Update Documentation (10 min)

Update `WORKSPACE_MIGRATION_STATUS.md` and `BUILD_OPTIMIZATION_PLAN.md` with new structure.

## Expected Results

### Before
- ❌ cargo-leptos build fails (tokio/mio WASM incompatibility)
- ✓ cargo check works

### After
- ✓ cargo-leptos build succeeds
- ✓ cargo check works
- ✓ SSR build includes full backend
- ✓ Hydrate build only includes api (WASM-compatible)

### Build Time Impact
- **No change to build times** - same code, different organization
- Dependency graph unchanged for SSR builds
- Hydrate builds slightly faster (no backend compilation)

## Rollback Plan

If issues arise:
1. Keep all files in git history
2. Revert commits in order
3. Backend still has all implementation code
4. Just need to un-split server_fn.rs

## Estimated Total Time
~2.5 hours for complete implementation and testing

## Files Modified Summary

**New files:**
- `crates/api/Cargo.toml`
- `crates/api/src/lib.rs`
- `crates/backend/src/implementations.rs`

**Modified files:**
- `Cargo.toml` (workspace)
- `crates/core/src/types.rs` (add 12 types)
- `crates/backend/src/lib.rs` (add implementations module)
- `crates/backend/Cargo.toml` (add usdfc-api dep)
- `crates/terminal/Cargo.toml` (add usdfc-api, update features)
- `crates/terminal/src/main.rs` (update imports)
- `crates/terminal/src/pages/*.rs` (17 files - update imports)

**Deleted files:**
- `crates/backend/src/server_fn.rs` (split into api/lib.rs + backend/implementations.rs)

## Migration Checklist

- [ ] Create api crate structure
- [ ] Move types to core
- [ ] Create api/lib.rs with server function declarations
- [ ] Create backend/implementations.rs
- [ ] Update workspace Cargo.toml
- [ ] Update terminal imports (automated with sed)
- [ ] Update main.rs imports
- [ ] Test: cargo check -p usdfc-api
- [ ] Test: cargo check -p usdfc-api --features ssr
- [ ] Test: cargo check -p usdfc-backend
- [ ] Test: cargo check -p usdfc-analytics-terminal --features hydrate
- [ ] Test: cargo leptos build --release
- [ ] Commit and push
- [ ] Deploy to Railway
- [ ] Verify pagination works

## Alternative Approach (Simpler but Less Clean)

If the above is too complex, a simpler approach:

1. Keep server_fn.rs in backend
2. Create backend/Cargo.toml features:
   ```toml
   [features]
   default = []
   ssr = ["tokio", "axum", "reqwest", ...]
   stubs = []  # Just the function signatures, no implementations
   ```

3. Guard all non-server-function code with `#[cfg(feature = "ssr")]`
4. In hydrate mode, backend compiles with `stubs` feature only

**Pros:** Less file movement
**Cons:** Backend Cargo.toml becomes complex, harder to maintain

**Recommendation:** Use the main approach (split into api crate) for cleaner architecture.
